/******************************************************************************
 * File: redisexpire.c
 * Author: Ernest Rozloznik (e@er400.io)
 * Date: 2025-02-27
 * Description: Implementation of the Redis EXPIRE function for IBM i.
 *              This function sets an expiration time (TTL) in seconds for a Redis key.
 *              The function is designed to be used in an ILE environment and
 *              interacts with a Redis server via TCP/IP.
 * License: MIT (https://opensource.org/licenses/MIT)
 * Version: 1.0.0
 ******************************************************************************/

// #define USE_ICONV 1
#include "redis_utils.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#ifdef USE_ICONV
#include <qtqiconv.h>
#endif

/**********************************************************************/
/* SQL External Function */
/**********************************************************************/

/**
 * Function: expireRedisKey
 * Description: SQL external function to set an expiration time for a Redis key.
 * Parameters:
 *   - key: Input Redis key (VARCHAR(255), EBCDIC).
 *   - ttl: Input time-to-live in seconds (INTEGER).
 *   - result: Output result (SMALLINT, 1 if expiration set, 0 if key does not exist).
 *   - keyInd: Null indicator for the input key.
 *   - ttlInd: Null indicator for the input TTL.
 *   - resultInd: Null indicator for the output result.
 *   - sqlstate: SQLSTATE (5 chars, e.g., "00000").
 *   - funcname: Fully qualified function name.
 *   - specname: Specific name.
 *   - msgtext: Error message text (up to 70 chars).
 *   - sqlcode: SQLCODE (optional, not used here).
 *   - nullind: Additional null indicators for DB2SQL.
 */
void SQL_API_FN expireRedisKey(
    SQLUDF_VARCHAR *key,       // Input: Redis key (VARCHAR(255), EBCDIC)
    SQLUDF_INTEGER *ttl,       // Input: TTL in seconds (INTEGER)
    SQLUDF_SMALLINT *result,   // Output: Result (SMALLINT, 1 or 0)
    SQLUDF_NULLIND *keyInd,    // Null indicator for input key
    SQLUDF_NULLIND *ttlInd,    // Null indicator for input TTL
    SQLUDF_NULLIND *resultInd, // Null indicator for output result
    char *sqlstate,            // SQLSTATE (5 chars, e.g., "00000")
    char *funcname,            // Fully qualified function name
    char *specname,            // Specific name
    char *msgtext,             // Error message text (up to 70 chars)
    short *sqlcode,            // SQLCODE (optional, not used here)
    SQLUDF_NULLIND *nullind)   // Additional null indicators for DB2SQL
{
    int sockfd;
    char ebcdic_send_buf[512], ascii_send_buf[512], recv_buf[1024], ebcdic_payload[1024];
    char ebcdic_key_len[10] = {0}, ebcdic_ttl_len[10] = {0};
    int len, total_len = 0;

#ifdef USE_ICONV
    // Initialize iconv conversion descriptors if not already initialized
    if (!initialized)
    {
        initialize_conversion();
        initialized = 1;
    }
    if (errno != 0)
    {
        strcpy(sqlstate, "38999");
        strcpy(msgtext, "iconv initialization failed");
        *resultInd = -1;
        return;
    }
#endif

    // Check for NULL input key or TTL
    if (*keyInd < 0)
    {
        strcpy(sqlstate, "38001");
        strcpy(msgtext, "Input key is NULL");
        *resultInd = -1;
        return;
    }
    if (*ttlInd < 0)
    {
        strcpy(sqlstate, "38002");
        strcpy(msgtext, "Input TTL is NULL");
        *resultInd = -1;
        return;
    }
    if (*ttl < 0)
    {
        strcpy(sqlstate, "38003");
        strcpy(msgtext, "TTL must be non-negative");
        *resultInd = -1;
        return;
    }

    // Initialize SQLSTATE to success
    strcpy(sqlstate, "00000");
    *result = 0;
    *resultInd = 0;

    // Connect to Redis
    if (connect_to_redis(&sockfd) != 0)
    {
        strcpy(sqlstate, "38901");
        strcpy(msgtext, "Failed to connect to Redis");
        *resultInd = -1;
        return;
    }

    // Format Redis EXPIRE command in EBCDIC
    ebcdic_send_buf[0] = '\0';
    int key_len = strlen(key);
    int ttl_len = snprintf(NULL, 0, "%d", *ttl); // Get TTL string length

    // Format key length in EBCDIC
    if (key_len < 10)
    {
        ebcdic_key_len[0] = 0xF0 + key_len;
        ebcdic_key_len[1] = '\0';
    }
    else
    {
        int i = 0, temp_len = key_len;
        while (temp_len > 0)
        {
            ebcdic_key_len[i++] = 0xF0 + (temp_len % 10);
            temp_len /= 10;
        }
        ebcdic_key_len[i] = '\0';
        for (int j = 0; j < i / 2; j++)
        {
            char tmp = ebcdic_key_len[j];
            ebcdic_key_len[j] = ebcdic_key_len[i - 1 - j];
            ebcdic_key_len[i - 1 - j] = tmp;
        }
    }

    // Format TTL length in EBCDIC
    if (ttl_len < 10)
    {
        ebcdic_ttl_len[0] = 0xF0 + ttl_len;
        ebcdic_ttl_len[1] = '\0';
    }
    else
    {
        int i = 0, temp_len = ttl_len;
        while (temp_len > 0)
        {
            ebcdic_ttl_len[i++] = 0xF0 + (temp_len % 10);
            temp_len /= 10;
        }
        ebcdic_ttl_len[i] = '\0';
        for (int j = 0; j < i / 2; j++)
        {
            char tmp = ebcdic_ttl_len[j];
            ebcdic_ttl_len[j] = ebcdic_ttl_len[i - 1 - j];
            ebcdic_ttl_len[i - 1 - j] = tmp;
        }
    }

    // Build EXPIRE command in EBCDIC: "*3\r\n$6\r\nEXPIRE\r\n$<key_len>\r\n<key>\r\n$<ttl_len>\r\n<ttl>\r\n"
    strcat(ebcdic_send_buf, "\x5C\xF3\x0D\x25\x5B\xF6\x0D\x25\xC5\xE7\xD7\xC9\xD9\xC5\x0D\x25"); // EBCDIC "*3\r\n$6\r\nEXPIRE\r\n"
    strcat(ebcdic_send_buf, "\x5B");
    strcat(ebcdic_send_buf, ebcdic_key_len);
    strcat(ebcdic_send_buf, "\x0D\x25");
    strcat(ebcdic_send_buf, key);
    strcat(ebcdic_send_buf, "\x0D\x25\x5B");
    strcat(ebcdic_send_buf, ebcdic_ttl_len);
    strcat(ebcdic_send_buf, "\x0D\x25");
    char ttl_str[11];
    snprintf(ttl_str, sizeof(ttl_str), "%d", *ttl);
    for (int i = 0; ttl_str[i]; i++)
        ttl_str[i] = ttl_str[i] - '0' + 0xF0; // Convert ASCII digits to EBCDIC
    strcat(ebcdic_send_buf, ttl_str);
    strcat(ebcdic_send_buf, "\x0D\x25");

    // Convert EBCDIC EXPIRE command to ASCII before sending
    ascii_send_buf[0] = '\0';
    size_t ebcdic_len_size = strlen(ebcdic_send_buf);
    if (ConvertToASCII(ebcdic_send_buf, ebcdic_len_size, ascii_send_buf, sizeof(ascii_send_buf) - 1) < 0)
    {
        strcpy(sqlstate, "38902");
        strcpy(msgtext, "Failed to convert command to ASCII");
        *resultInd = -1;
        close(sockfd);
        return;
    }
    ascii_send_buf[ebcdic_len_size] = '\0';

    // Send EXPIRE command to Redis
    len = send(sockfd, ascii_send_buf, strlen(ascii_send_buf), 0);
    if (len < 0)
    {
        strcpy(sqlstate, "38903");
        strcpy(msgtext, "Failed to send command to Redis");
        *resultInd = -1;
        close(sockfd);
        return;
    }

    // Receive response from Redis
    len = recv(sockfd, recv_buf, sizeof(recv_buf) - 1, 0);
    if (len < 0)
    {
        if (errno == EWOULDBLOCK || errno == EAGAIN)
        {
            strcpy(sqlstate, "38904");
            strcpy(msgtext, "Receive timeout from Redis");
        }
        else
        {
            strcpy(sqlstate, "38905");
            strcpy(msgtext, "Failed to receive data from Redis");
        }
        *resultInd = -1;
        close(sockfd);
        return;
    }
    else if (len == 0)
    {
        strcpy(sqlstate, "38906");
        strcpy(msgtext, "Connection closed by Redis");
        *resultInd = -1;
        close(sockfd);
        return;
    }

    total_len = len;
    recv_buf[total_len] = '\0';

    // Convert ASCII response to EBCDIC
    if (ConvertToEBCDIC(recv_buf, total_len, ebcdic_payload, sizeof(ebcdic_payload) - 1) < 0)
    {
        strcpy(sqlstate, "38907");
        strcpy(msgtext, "Failed to convert response to EBCDIC");
        *resultInd = -1;
        close(sockfd);
        return;
    }
    ebcdic_payload[total_len] = '\0';

    // Extract Redis response
    char *payload = NULL;
    size_t payload_length;
    if (extract_redis_payload(ebcdic_payload, &payload, &payload_length) == 0)
    {
        // Parse the integer value from the payload
        *result = atoi(payload); // Convert the payload to a SMALLINT (1 or 0)
        *resultInd = 0;
    }
    else
    {
        strcpy(sqlstate, "38908");
        strcpy(msgtext, "Failed to extract payload from Redis response");
        *resultInd = -1;
    }
    //if (payload)
    //    free(payload);

    close(sockfd);
}

#pragma linkage(expireRedisKey, OS)